package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"

{{range $node := .Nodes}}{{range $event := $.Events.Subscribe}}	"github.com/nats-io/nats.go"
{{break}}{{end}}{{break}}{{end}}	dalclient "itsm-platform/services/dal-service/client"
	"itsm-platform/sdk/dsl"
	natssdk "itsm-platform/sdk/nats"
	graphsync "itsm-platform/sdk/graph"
	"{{.ServiceName}}-service/handlers"{{range $node := .Nodes}}{{if $node.Graph.Sync}}
	"github.com/jackc/pgx/v5/pgxpool"{{break}}{{end}}{{end}}
)

type {{.ServiceNamePascal}}Service struct {
	natsManager *natssdk.ServiceManager
	dal         *dalclient.Client
	handlers    *handlers.{{.ServiceNamePascal}}Handlers
	graph       *dsl.ServiceGraph
	graphSync   *graphsync.SyncManager
}

func main() {
	// Load DSL configuration
	dslPath := getEnv("DSL_PATH", "./dsl/service.json")
	graph, err := loadDSL(dslPath)
	if err != nil {
		log.Fatal(err)
	}

	// Create NATS service manager
	natsURL := getEnv("NATS_URL", "nats://localhost:4222")
	natsManager, err := natssdk.NewServiceManager(natsURL, graph)
	if err != nil {
		log.Fatal(err)
	}
	defer natsManager.Close()

	// Create DAL client
	dalClient := dalclient.NewClient(natsManager.GetConnection(), "{{.ServiceName}}")

	// Register service DSL with DAL
	if err := registerWithDAL(dalClient, graph); err != nil {
		log.Fatal(err)
	}

	// Initialize graph synchronization if enabled
	var graphSync *graphsync.SyncManager
	if hasGraphSyncEnabled(graph) {
		// Connect to database for graph sync
		dbURL := getEnv("DATABASE_URL", "postgres://itsm_user:itsm_pass@localhost/itsm_db")
		dbPool, err := connectToDatabase(dbURL)
		if err != nil {
			log.Printf("Failed to connect to database for graph sync: %v", err)
		} else {
			graphSync = graphsync.NewSyncManager(dbPool, graph)
			if err := graphSync.InitGraph(context.Background()); err != nil {
				log.Printf("Failed to initialize graph: %v", err)
			} else {
				log.Printf("Graph synchronization initialized for {{.ServiceName}}")
			}
		}
	}

	// Create service
	service := &{{.ServiceNamePascal}}Service{
		natsManager: natsManager,
		dal:         dalClient,
		handlers:    handlers.New{{.ServiceNamePascal}}Handlers(dalClient, natsManager.GetConnection(), graphSync),
		graph:       graph,
		graphSync:   graphSync,
	}

	// Setup NATS subscriptions
	if err := service.setupSubscriptions(); err != nil {
		log.Fatal(err)
	}

	// Start the service
	ctx := context.Background()
	if err := natsManager.StartService(ctx); err != nil {
		log.Fatal(err)
	}

	log.Printf("{{.ServiceNamePascal}} service started")

	// Wait for shutdown signal
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)
	<-sig

	log.Println("Shutting down {{.ServiceName}} service...")
}

func (s *{{.ServiceNamePascal}}Service) setupSubscriptions() error {
{{range $node := .Nodes}}	// Register {{$node.Name}} handlers
	if err := s.natsManager.RegisterEntityHandlers("{{$node.Name}}", 
		s.handlers.Handle{{$node.Name}}Create,
		s.handlers.Handle{{$node.Name}}Update,
		s.handlers.Handle{{$node.Name}}Delete,
		s.handlers.Handle{{$node.Name}}Get,
		s.handlers.Handle{{$node.Name}}Query); err != nil {
		return err
	}
{{end}}
{{if .Events.Subscribe}}
	// Register event handlers for cross-service events
	eventHandlers := map[string]func(*nats.Msg){
{{range $event := .Events.Subscribe}}		"{{$event.Subject}}": s.handlers.OnCustomerDeleted,
{{end}}	}
	return s.natsManager.RegisterEventHandlers(eventHandlers)
{{else}}
	return nil
{{end}}}

func loadDSL(dslPath string) (*dsl.ServiceGraph, error) {
	data, err := os.ReadFile(dslPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read DSL file: %w", err)
	}

	var graph dsl.ServiceGraph
	if err := json.Unmarshal(data, &graph); err != nil {
		return nil, fmt.Errorf("failed to parse DSL: %w", err)
	}

	return &graph, nil
}

func registerWithDAL(dalClient *dalclient.Client, graph *dsl.ServiceGraph) error {
	// Convert graph to map for DAL registration
	dslMap := make(map[string]interface{})
	data, _ := json.Marshal(graph)
	json.Unmarshal(data, &dslMap)
	
	return dalClient.RegisterService("{{.ServiceName}}", dslMap)
}

func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

// hasGraphSyncEnabled checks if any nodes have graph sync enabled
func hasGraphSyncEnabled(graph *dsl.ServiceGraph) bool {
	for _, node := range graph.Nodes {
		if node.Graph.Sync {
			return true
		}
	}
	return false
}

// connectToDatabase connects to PostgreSQL for graph operations
func connectToDatabase(dbURL string) (*pgxpool.Pool, error) {
	config, err := pgxpool.ParseConfig(dbURL)
	if err != nil {
		return nil, err
	}
	
	ctx := context.Background()
	pool, err := pgxpool.NewWithConfig(ctx, config)
	if err != nil {
		return nil, err
	}
	
	// Test the connection
	if err := pool.Ping(ctx); err != nil {
		return nil, err
	}
	
	return pool, nil
}